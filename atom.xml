<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yja.hualian.host</id>
    <title>Yja&apos;s blog</title>
    <updated>2020-07-31T11:02:05.481Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yja.hualian.host"/>
    <link rel="self" href="https://yja.hualian.host/atom.xml"/>
    <subtitle>稻花香里说丰年，听取WA声一片</subtitle>
    <logo>https://yja.hualian.host/images/avatar.png</logo>
    <icon>https://yja.hualian.host/favicon.ico</icon>
    <rights>All rights reserved 2020, Yja&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[[图论]最小生成树模板题 | 最小生成树]]></title>
        <id>https://yja.hualian.host/post/tu-lun-zui-xiao-sheng-cheng-shu-mo-ban-ti-or-zui-xiao-sheng-cheng-shu/</id>
        <link href="https://yja.hualian.host/post/tu-lun-zui-xiao-sheng-cheng-shu-mo-ban-ti-or-zui-xiao-sheng-cheng-shu/">
        </link>
        <updated>2020-07-31T09:22:01.000Z</updated>
        <content type="html"><![CDATA[<h3 id="描述">描述</h3>
<p>给出一个数字N，代表有N个点，然后给出这N个点的坐标。求一个最小生成树将这N个点连通起来。<br>
这里两点间的距离为欧几里德距离<br>
输入</p>
<p>整个测试有多组数据<br>
对于每组数据<br>
第一行给出数字N，N&lt;=1000<br>
接下来N行给点的坐标x,y.-10000 &lt;= X,Y &lt;= 10000<br>
整个测试以0代表结束<br>
输出</p>
<p>输出见样例。注意：如果是多组输出数据，多组输出数据之间多一个空行。<br>
样例</p>
<h3 id="输入">输入</h3>
<p>5<br>
0 0<br>
0 1<br>
1 1<br>
1 0<br>
0.5 0.5<br>
0</p>
<h3 id="输出">输出</h3>
<p>Case #1:<br>
The minimal distance is: 2.83</p>
<hr>
<h2 id="题目大意">题目大意</h2>
<p>如题，及求最小生成树，给一个n个点带边权的无向图，选n-1条边将图上所有点连接起来并使得树上所有边权之和最小。</p>
<h2 id="解题思路">解题思路</h2>
<p>对于求最小生成树问题，一般有<strong>prim</strong>和<strong>kruska</strong>l两种算法，本面着重讲prim算法。<br>
prim的算法核心是维护<strong>最小生成树的一部分</strong>，从刚开始的一个点开始逐渐扩展到n个点，在每次扩展时，从已经求出最小生成树的一部分中找一个点u，从还未被选入最小生成树中的点中找一个点v，如果两点之间有连边，从<strong>未被选入最小生成树点的集合</strong>删去v，把v点加入<strong>已经生成的最小生成树的集合</strong>里面，并累加两点之间连边的权值。</p>
<p>但如果用上面的朴素算法，每次访问1到n点中，又要从那个点开始向能走到的n个点的点进行打擂求出边权最小的加入，这要两个for循环n次才能完成，时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p><s>这么慢那学个什么，肯定是要学最快最优的那种啦</s></p>
<p>每次对于当前处理点i，要循环n次求出离它边权最小值的点，所以可以直接用堆来维护边权最小点集合，边权越小越优先处理，这样可以保证第一次算完所有点的就一定是最小生成树<br>
采用堆优化后时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlongn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<hr>
<p>奉上代码</p>
<pre><code class="language-c">#include&lt;bits/stdc++.h&gt;
using namespace std;
double x[1005],y[1005];
int n;
bool vis[1005];
struct node{
	double dist;
	int u;
	node(double dist_,int u_){
		dist=dist_;
		u=u_;
	}
	bool operator &lt; (const node &amp;a) const {
		return a.dist&lt;dist;
	}
};
void prim(){
	memset(vis,0,sizeof(vis));
	double ans=0.0;
	priority_queue&lt;node&gt; q;
	q.push(node(0.0,1));
	while(!q.empty()){
		int u=q.top().u;
		double dist=q.top().dist;
		q.pop();
		if(vis[u])
			continue;
		vis[u]=1;
		ans+=dist;
		for(int i=2;i&lt;=n;i++){
			if(!vis[i]){
				q.push(node(sqrt(pow(x[i]-x[u],2)*1.0+pow(y[i]-y[u],2)*1.0),i));
			}
		}
	}
	printf(&quot;%.2f&quot;,ans);
	return ;
}
int main(){
	int t=1;
	while(1){
		scanf(&quot;%d&quot;,&amp;n);
		if(n==0){
			return 0;
		}
		for(int i=1;i&lt;=n;i++){
			cin&gt;&gt;x[i]&gt;&gt;y[i];
		}
		printf(&quot;Case #%d:\n&quot;,t);
		printf(&quot;The minimal distance is: &quot;);
		prim();
		printf(&quot;\n\n&quot;);
		t++;
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[图论]奖金 | 拓扑排序]]></title>
        <id>https://yja.hualian.host/post/tu-lun-jiang-jin-or-tuo-bu-pai-xu/</id>
        <link href="https://yja.hualian.host/post/tu-lun-jiang-jin-or-tuo-bu-pai-xu/">
        </link>
        <updated>2020-07-31T08:50:12.000Z</updated>
        <content type="html"><![CDATA[<h3 id="描述">描述</h3>
<p>Mr.Z心情好，决定给每位员工发奖金。公司决定以每个人本年在公司的贡献为标准来计算他们得到奖金的多少。<br>
于是Mr.Z下令召开m方会谈。每位参加会谈的代表提出了自己的意见：“我认为员工a的奖金应该比b高！”Mr.Z决定要找出一种奖金方案，满足各位代表的意见，且同时使得总奖金数最少。每位员工奖金最少为100元。<br>
输入</p>
<p>第一行两个整数n,m，表示员工总数和代表数；<br>
以下m行，每行2个整数a,b，表示某个代表认为第a号员工奖金应该比第b号员工高。<br>
n&lt;=10000，m&lt;=20000<br>
输出</p>
<p>若无法找到合法方案，则输出“Poor Xed”；否则输出一个数表示最少总奖金。<br>
样例</p>
<h3 id="输入">输入</h3>
<p>2 1<br>
1 2</p>
<h3 id="输出">输出</h3>
<p>201</p>
<hr>
<h2 id="题目大意">题目大意</h2>
<p>给定一个有向图，如果存在环就输出Poor Xed，否则从一个入度为0点开始一直往下走，每个点的点权刚开始都为100，每往下走当前那个点的点权就要加上当前深度，最后输出所有点权值之和。</p>
<hr>
<h3 id="解题思路">解题思路</h3>
<p>假设有点a,b,c,a要比b多,b要比c多，c要比a多，这样构成了一个环，<strong>无论</strong>任意一个点为多少，都无法满足要求，所以用<strong>拓扑排序</strong>来找图里面是否有环，如果有就输出Poor Xed，否则进行求解。</p>
<p>采用拓扑排序的思想，如果一个点<strong>入度为0</strong>，没有其他人要求比它高，就抠门只给他100就可以满足题目的要求，既然这个点的问题解决了，他所连向的点入度都减1，但那些点可能是被多个点连着，要满足要求就得选要钱最多的那个+1，但他入度还没变成1，就留到后面来解决，如果就只有一个点连着，减1后入度刚好为0，没有其他点的约束，那么那个点的工资就是前一个点+1，并且把那个点放进队列里面等待处理。</p>
<hr>
<p>奉上代码<br>
不要问为什么叫hopsort，只是谐音拓扑而已s(σ°∀°)σ。</p>
<pre><code class="language-c">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m,tot,head[20002],indegree[20002];
struct G{
	int nex;
	int to;
}g[20002];
void add(int u,int v){
	g[++tot].nex=head[u];
	g[tot].to=v;
	head[u]=tot;
	return ;
}
int value[10005];
void hopsort(){
	queue&lt;int&gt; q;
	for(int i=1;i&lt;=n;i++){
		if(indegree[i]==0){
			q.push(i);
			value[i]=100;
		}
	}
	int cnt=0,ans=0;
	while(!q.empty()){
		int u=q.front();
		q.pop();
		cnt++;
		ans+=value[u];
		for(int i=head[u];i;i=g[i].nex){
			int v=g[i].to;
			indegree[v]--;
			value[v]=max(value[v],value[u]+1);
			if(indegree[v]==0){
				q.push(v);
			}
		}
	}
	if(cnt==n)
		printf(&quot;%d&quot;,ans);
	else
		puts(&quot;Poor Xed&quot;);
	return ;
}
int main(){
	scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=m;i++){
		int u,v;
		scanf(&quot;%d %d&quot;,&amp;u,&amp;v);
		add(v,u);
		indegree[u]++;
	}
	hopsort();
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[图论]牛跑步]]></title>
        <id>https://yja.hualian.host/post/tu-lun-niu-pao-bu/</id>
        <link href="https://yja.hualian.host/post/tu-lun-niu-pao-bu/">
        </link>
        <updated>2020-07-30T11:11:07.000Z</updated>
        <content type="html"><![CDATA[<h3 id="描述">描述</h3>
<p>BESSIE准备用从牛棚跑到池塘的方法来锻炼. 但是因为她懒,她只准备沿着下坡的路跑到池塘, 然后走回牛棚. BESSIE也不想跑得太远,所以她想走最短的路经. 农场上一共有M (1 &lt;= M &lt;= 10,000)条路, 每条路连接两个用1..N(1 &lt;= N &lt;= 1000)标号的地点. 更方便的是,如果X&gt;Y,则地点X的高度大于地点Y的高度. 地点N是BESSIE的牛棚;地点1是池塘. 很快, BESSIE厌倦了一直走同一条路.所以她想走不同的路,更明确地讲,她想找出K (1 &lt;= K &lt;= 100)条不同的路经.为了避免过度劳累,她想使这K条路经为最短的K条路经. 请帮助BESSIE找出这K条最短路经的长度.你的程序需要读入农场的地图, 一些从X_i到Y_i 的路经和它们的长度(X_i, Y_i, D_i). 所有(X_i, Y_i, D_i)满足(1 &lt;= Y_i &lt; X_i; Y_i &lt; X_i &lt;= N, 1 &lt;= D_i &lt;= 1,000,000).<br>
输入</p>
<ul>
<li>
<p>第1行: 3个数: N, M, 和K</p>
</li>
<li>
<p>第 2..M+1行: 第 i+1 行包含3个数 X_i, Y_i, 和 D_i, 表示一条下坡的路.<br>
输出</p>
</li>
<li>
<p>第1..K行: 第i行包含第i最短路经的长度,或-1如果这样的路经不存在.如果多条路经有同样的长度,请注意将这些长度逐一列出.<br>
样例</p>
</li>
</ul>
<h3 id="输入">输入</h3>
<p>5 8 7<br>
5 4 1<br>
5 3 1<br>
5 2 1<br>
5 1 1<br>
4 3 4<br>
3 1 1<br>
3 2 1<br>
2 1 1</p>
<h3 id="输出">输出</h3>
<p>1<br>
2<br>
2<br>
3<br>
6<br>
7<br>
-1</p>
<h3 id="提示">提示</h3>
<p>//路经分别为(5-1), (5-3-1), (5-2-1), (5-3-2-1), (5-4-3-1),(5-4-3-2-1).</p>
<hr>
<h2 id="题目大意">题目大意</h2>
<p>给定一个n个点m条边<strong>带边权</strong>的<strong>有向图</strong>，求其第<strong>1到k</strong>短路的长度，编号<strong>大</strong>的点只能走向比编号<strong>小</strong>的点。</p>
<hr>
<h2 id="大致想法">大致想法</h2>
<p>求k短路可暴力枚举删去最短路上的k条边，但这道题n较大而且是要重复求k次k短路，时间复杂度直接成指数级别增长。可以采取一种比较高效的半分，A*+dij(当然可以堆优化)。</p>
<h3 id="何为a">何为A*</h3>
<p>A*(A star)，又称为启发式搜索。可以看成是升级版的bfs<s>虽然不太严谨，但也找不出更好形容的了</s>，一般地<br>
设h为<strong>当前状态</strong>到<strong>目标状态</strong>的<strong>估计代价</strong><br>
设f为<strong>当前状态</strong>到<strong>目标状态</strong>的<strong>实际代价</strong></p>
<p>A*算法的核心就是<strong>估价函数</strong>，求当前状态估计到目标状态的最小(或者最大)代价(即是求h)，采用优先队列把估计代价最小（或最大，根据题目而定）的状态放在队首优先处理，这样更接近目标状态的会<strong>优先处理</strong>从而更快地算出答案。<strong>h是一定要小于等于f的</strong>，如果大于f，原本要优先处理的状态会被压到队尾降低程序运行效率，甚至无法得到处理而算不出答案。</p>
<p>如果当h为定值时，无论状态如何h都不会改变，优先队列以h为关键字的排序就毫无意义，这就成了bfs，同样当h只更状态处理的先后顺序改变时，这就成了dfs</p>
<p>由此可见设计一个合理的估价函数对于A*算法的效率非常重要，当h=f时，A*算法第一个出队列的答案就是最优解。</p>
<hr>
<h3 id="何为dij">何为dij</h3>
<p>dij就是dijkstar，求<strong>单源最短路</strong>（从一个定点出发到其他点的最短距离，不同与floyd）的一种算法。<br>
采取堆优化就是每次处理点时优先将当前已经算出来的路径长度优先处理，尽管有时候当前最优解不一定是全局最优解，但仍比朴素的dij快得多。</p>
<hr>
<h3 id="解题思路">解题思路</h3>
<p>首先用dij优先预处理出每个个点到终点的最短路径，可以存反图以终点为起点求到其他点的最短路径，设dist[i]为i到终点的最短路径，这样就有了对于i点非常准确的<strong>估价</strong>，再采用A*算法，从起点开始向终点搜索，每到一个点时就求出<strong>起点到当前点的路径长度</strong>再加上对于当前点<strong>估计</strong>到终点的路径长度，以此为关键字在优先队列里面排序，每次<strong>优先处理</strong>到终点路径最短的状态，由于估价就是<strong>真实的</strong>从i点到终点最短的路径长度，所以每次优先处理的点<strong>一定是</strong>所有搜的点中最短路那个</p>
<h4 id="所以到到达终点第一个出来的结果就一定是最短路第二个就一定是次短路第三个就一定是第三短的路径">所以到到达终点，第一个出来的结果就一定是最短路，第二个就一定是次短路，第三个就一定是第三短的路径。</h4>
<p>最后只需要记录到终点状态出队列次数，到了k次就输出了全部的答案，如果没到就没有足够的路径到达终点，就输出剩下次数个数的-1</p>
<hr>
<p>奉上代码</p>
<pre><code class="language-c">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m,vis[10005],k,tot,head[20005],tot2,head2[20005],f[1005];
struct G{
	int nex;
	int to;
	int w;
}g[20005],g2[20005];
struct node{
	int dist;
	int u;
	int f;
	node(int dist_,int u_,int f_){
		dist=dist_;
		u=u_;
		f=f_;
	}
	bool operator &lt; (const node a) const {
		return f&gt;a.f;
	}
};
void add(int u,int v,int w){
	g[++tot].nex=head[u];
	g[tot].to=v;
	g[tot].w=w;
	head[u]=tot;
	return ;
}
void add2(int u,int v,int w){
	g2[++tot2].nex=head2[u];
	g2[tot2].to=v;
	g2[tot2].w=w;
	head2[u]=tot2;
	return ;
}
void dij(int s){
	priority_queue&lt;pair&lt;int,int&gt; &gt; q;
	q.push(make_pair(0,s));
	vis[s]=1;
	memset(f,0x3f,sizeof(f));
	f[s]=0;
	while(!q.empty()){
		if(-q.top().first!=f[q.top().second]){
			q.pop();
			continue;
		}
		int u=q.top().second;
		q.pop();
		for(int i=head2[u];i;i=g2[i].nex){
			int v=g2[i].to;
			int w=g2[i].w;
			if(f[v]&gt;f[u]+w){
				f[v]=f[u]+w;
				q.push(make_pair(-f[v],v));
			}
		}
	}
	return ;
}

void Astar(int s){
	priority_queue&lt;node&gt; q;
	q.push(node(0,s,f[s]));
	while(!q.empty()){
		int u=q.top().u;
		int d=q.top().dist;
		q.pop();
		if(u==1){
			printf(&quot;%d\n&quot;,d);
			if(--k==0)
				return ;
		}
		for(int i=head[u];i;i=g[i].nex){
			int v=g[i].to;
			int w=g[i].w;
			q.push(node(d+w,v,w+d+f[v]));
		}
	}
	while(k--){
		puts(&quot;-1&quot;);
	}
	return ;
}
int main(){
	//freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin);
	scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;k);
	for(int i=1;i&lt;=m;i++){
		int u,v,w;
		scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w);
		add(u,v,w);
		add2(v,u,w);
	}
	dij(1);
	Astar(n);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[动态规划]Cow Pie Treasures]]></title>
        <id>https://yja.hualian.host/post/dong-tai-gui-hua-cow-pie-treasures/</id>
        <link href="https://yja.hualian.host/post/dong-tai-gui-hua-cow-pie-treasures/">
        </link>
        <updated>2020-07-27T10:21:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="description">Description</h3>
<p>最近，奶牛们热衷于把金币包在面粉里，然后把它们烤成馅饼。第i块馅饼中含有Ni(1&lt;=Ni&lt;=25)块金币，并且，这个数字被醒目地标记在馅饼表面。 奶牛们把所有烤好的馅饼在草地上排成了一个R行(1&lt;=R&lt;=100)C列(1&lt;=C&lt;=100)的矩阵。你现在站在坐标为(1,1)的馅饼边上，当然，你可以拿到那块馅饼里的所有金币。你必须从现在的位置，走到草地的另一边，在坐标为(R,C)的馅饼旁边停止走动。每做一次移动，你必须走到下一列的某块馅饼旁边，并且，行数的变动不能超过1（也就是说，如果现在你站在坐标为(r,c)的馅饼边上，下一步你可以走到坐标为(r-1,c+1),(r,c+1),或者(r+1,c+1)的馅饼旁边）。当你从一块馅饼边经过，你就可以拿走馅饼里所有的金币。当然啦，你一定不会愿意因半路离开草地而失去唾手可得的金币，但，最终你一定得停在坐标为(R,C)的馅饼旁边。 现在，你拿到了一张标记着馅饼矩阵中，每一块馅饼含金币数量的表格。那么，按照规则，你最多可以拿到多少金币呢？ 比方说，奶牛们把馅饼排成如下的矩阵，矩阵中的数字表示该位置的馅饼中含金币的数量：<br>
6 5 3 7 9 2 7<br>
2 4 3 5 6 8 6<br>
4 9 9 9 1 5 8<br>
以下是条合法的路线<br>
<img src="https://i.loli.net/2020/07/27/yLuw1Dj6b7Qhnqo.gif" alt="image001.gif" loading="lazy"></p>
<p>按上述的路线进行走动，一共可以获得6+4+9+9+6+5+8=47个金币．按照规则，在这个矩阵中最多可以得到50个金币，路线如下图所示：<br>
<img src="https://i.loli.net/2020/07/27/deXYwVx9OQuyqkI.gif" alt="image002.gif" loading="lazy"></p>
<p>Input<br>
第1行: 两个用空格隔开的整数，R和C<br>
第2..R+1行: 每行包含C个用空格隔开的正整数，依次表示一行中从左往右各个馅饼里金币的数量<br>
Output<br>
输出一个正整数，表示你所能收集到的最大金币数目</p>
<h3 id="sample-input">Sample Input</h3>
<p>3 7<br>
6 5 3 7 9 2 7<br>
2 4 3 5 6 8 6<br>
4 9 9 9 1 5 8</p>
<h3 id="sample-output">Sample Output</h3>
<p>50</p>
<hr>
<h2 id="题目大意">题目大意</h2>
<p>一个n*m的地图从地图左上角走到右下角，每次可以往右，右上，右下走，在每个格子都有一定的金币，每经过一个格子就可以获得格子里面的金币，求从左上角走到左下角可以获得的最大金币的数量。</p>
<hr>
<h2 id="解题思路">解题思路</h2>
<p>根据题目描述可以知道n和m的值比较小，而且牛是不可能往左走的，所以不用考虑重复走的问题，只用一个劲往右莽就行了。<br>
这道题可以采用bfs，但<s>dp不香吗</s>dp求解速度更快代码更短。</p>
<p>设dp[i][j]为从1,1走到i,j所得到的最大金币数，x[i][j]为i,j的格子里面金币的数量。而奶牛只能往右，右上，右下走，对应i行数就不变或，-1，+1，而列数j都要加1向右移动。<br>
易得状态转移方程:<br>
dp[i][j+1]=max(dp[i][j+1],dp[i][j]+x[i][j+1]);<br>
dp[i+1][j+1]=max(dp[i+1][j+1],dp[i][j]+x[i+1][j+1]);<br>
dp[i-1][j+1]=max(dp[i-1][j+1],dp[i][j]+x[i-1][j+1]);</p>
<p>那么直接套个双重for循环i从1到n，j从1到m求出dp[i][j]最终输出dp[n][m]就可以了。<br>
看到这里就恭喜你可以<br>
<strong>WA</strong>掉这道题了。</p>
<p>循环是从左上到右下的，那么以题为例，你的dp[i][j]更新值时的路径就是<img src="https://i.loli.net/2020/07/27/7pqmRjBDCQPVlG9.png" alt="无标题.png" loading="lazy"><br>
那么当你在更新别的dp值时候就会<br>
<img src="https://cdn.jsdelivr.net/gh/pic-cdn/cdn2@latest/2020/07/27/8747665c54e8a9853e17c37711256646.png" alt="" loading="lazy"><br>
对右，右下的更新都没问题，因为还没走到那里。但对右上的更新就不太妙了。右上的元素是已经枚举处理过了，从正在走的点去更新已经走过的点就会出大问题，动态规划其中的要求就是无后效性，即当前的值不会去影响之前已经算好了的值。<br>
当前的值是之前算出来的，而现在又去更新之前的值，所以当前的值也得改变，那所以之前的值又要改变...<s>无限套娃</s></p>
<p>要解决这个问题，改变循环枚举的方式，从原本的i行遍历j列，到j列遍历i行，那么循环遍历的路径就会如下图所示:<br>
<img src="https://cdn.jsdelivr.net/gh/pic-cdn/cdn2@latest/2020/07/27/1fc5e1bd8dcffcda48d6e08ff6e6540c.png" alt="" loading="lazy"><br>
对于任意一个点所更新其他点的情况就会这样<br>
<img src="https://cdn.jsdelivr.net/gh/pic-cdn/cdn2@latest/2020/07/27/e000b6767583c7d8d011cc9708d7c515.png" alt="" loading="lazy"><br>
而那些点都是还没走过的，并且那些点都是不可能走到现在的点（题目说了奶牛只能往右走 ），所以也就不会影响当前的值。<br>
那么只需要把原来的</p>
<pre><code class="language-c">for(int i=1;i&lt;=n;i++){
    for(int j=1;j&lt;=m;j++){
        ...(转移方程)
    }
}
</code></pre>
<p>改成</p>
<pre><code class="language-c">for(int j=1;j&lt;=m;j++){
    for(int i=1;i&lt;=n;i++){
        ...(转移方程)
    }
}
</code></pre>
<p>终于可以AC掉这道题了</p>
<p>提交，评测，刷新<strong>WA</strong>掉了〒▽〒</p>
<hr>
<h2 id="最终解法">最终解法</h2>
<p>题目说了奶牛最多就只能往右下走，所以地图上游戏点是无论如何也走不到的，最多也就能这样<br>
<img src="https://cdn.jsdelivr.net/gh/pic-cdn/cdn2@latest/2020/07/27/32dfef5213fb8a16a656419b08e8df22.png" alt="" loading="lazy"><br>
那些被涂掉的点是无论如何也都走不到的，而在循环时那些点还是会被遍历并更新其他值，根据上图显而易见i要&lt;=j才有可能走到。，所以在循环时候加上一个判断就可以啦</p>
<hr>
<p>奉上代码</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m,x[105][105],dp[105][105];
int main(){
	scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=m;j++){
			scanf(&quot;%d&quot;,&amp;x[i][j]);
		}
	}
	dp[1][1]=x[1][1];
	for(int j=1;j&lt;=m;j++){
		for(int i=1;i&lt;=n &amp;&amp; i&lt;=j;i++){
			dp[i][j+1]=max(dp[i][j+1],dp[i][j]+x[i][j+1]);
			dp[i+1][j+1]=max(dp[i+1][j+1],dp[i][j]+x[i+1][j+1]);
			dp[i-1][j+1]=max(dp[i-1][j+1],dp[i][j]+x[i-1][j+1]);
		}
	}
	printf(&quot;%d&quot;,dp[n][m]);
	return 0;
}
</code></pre>
<p>别往下看了，不会再WA了</p>
<p>真的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[树形dp]没有上司的舞会]]></title>
        <id>https://yja.hualian.host/post/shu-xing-dpmei-you-shang-si-de-wu-hui/</id>
        <link href="https://yja.hualian.host/post/shu-xing-dpmei-you-shang-si-de-wu-hui/">
        </link>
        <updated>2020-07-26T12:02:09.000Z</updated>
        <content type="html"><![CDATA[<h3 id="描述">描述</h3>
<p>有个公司要举行一场晚会。<br>
为了能玩得开心，公司领导决定：如果邀请了某个人，那么一定不会邀请他的上司<br>
（上司的上司，上司的上司的上司……都可以邀请）。</p>
<h3 id="题目">题目</h3>
<p>每个参加晚会的人都能为晚会增添一些气氛，求一个邀请方案，使气氛值的和最大。<br>
输入</p>
<p>第1行一个整数N（1&lt;=N&lt;=6000）表示公司的人数。<br>
接下来N行每行一个整数。第i行的数表示第i个人的气氛值x(-128&lt;=x&lt;=127)。<br>
接下来每行两个整数L，K。表示第K个人是第L个人的上司。<br>
输入以0 0结束。<br>
输出</p>
<p>一个数，最大的气氛值和。<br>
样例</p>
<h3 id="输入">输入</h3>
<p>7<br>
1<br>
1<br>
1<br>
1<br>
1<br>
1<br>
1<br>
1 3<br>
2 3<br>
6 4<br>
7 4<br>
4 5<br>
3 5<br>
0 0</p>
<h4 id="输出">输出</h4>
<p>5</p>
<hr>
<h2 id="题目大意">题目大意</h2>
<p>n个点，每个点有一个气氛值，当选了第i个点时就不能选它的父亲节点，但是可以选它父亲的父亲，求其能选出气氛值之和最大为多少。</p>
<hr>
<h2 id="解题思路">解题思路</h2>
<p>像这种有主从关系的，不难想到图或树，而根据题意可以判断出这个图是没有环的，上司的上司不可能是上司的下属吧，那就可以直接上树。</p>
<p>注意上司和下属的关系是决定了这棵树是单向边的，题目也没说明那个一定是根节点，所以不能随便从一个点开始搜，先预处理出一个没有入度的点以其为根节点再开始搜<br>
设bool数组vis[i]为i是否有上司，用一个for循环遍历一遍找到一个vis值为零的开始搜即可</p>
<p>设dp[u][j(j只为1或0)]为当第u个人来(j为1)与不来(j为0)时所能产生的最大气氛值。<br>
图的遍历一遍使用dfs,设i的儿子为v，根据题意上司来了其下属就不会来，下属来了其上司就不会来。<br>
但上司不来下属来与不来都可以<br>
可得状态转移方程:<br>
dp[u][0]+=max(dp[v][1],dp[v][0])；<br>
设w[i]为第i个人来能带来的气氛值<br>
dp[u][1]=w[i];<br>
dp[u][1]+=dp[v][0];</p>
<p>设root为树的根节点<br>
最后输出dp[root][0]和dp[root][1]中最大的值即可。</p>
<hr>
<p>奉上代码</p>
<pre><code class="language-c">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,w[6005],tot,head[12005],dp[6005][2];
bool vis[6005];
struct node{
	int nex;
	int to;
}g[12005];
void add(int u,int v){
	g[++tot].nex=head[u];
	g[tot].to=v;
	head[u]=tot;
}
void dfs(int u){
	
	dp[u][0]=0;
	dp[u][1]=w[u];
	int v=0;
	for(int i=head[u];i;i=g[i].nex)
		v=g[i].to,
		dfs(v),
		dp[u][0]+=max(dp[v][1],dp[v][0]),
		dp[u][1]+=dp[v][0];
		
	return ;
}
int main(){
	
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;w[i]);
	
	int u=-1,v=-1;
	while(u!=0 &amp;&amp; v!=0)
		scanf(&quot;%d %d&quot;,&amp;u,&amp;v),
		add(v,u),
		vis[u]=1;
	
	int root=0;
	for(int i=1;i&lt;=n;i++)
		if(!vis[i]){
			root=i;
			break;
		}
	
	dfs(root);
	printf(&quot;%d&quot;,max(dp[root][1],dp[root][0]));
	
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[状压dp]传球游戏之最小总代价]]></title>
        <id>https://yja.hualian.host/post/zhuang-ya-dpchuan-qiu-you-xi-zhi-zui-xiao-zong-dai-jie/</id>
        <link href="https://yja.hualian.host/post/zhuang-ya-dpchuan-qiu-you-xi-zhi-zui-xiao-zong-dai-jie/">
        </link>
        <updated>2020-07-26T11:30:02.000Z</updated>
        <content type="html"><![CDATA[<h3 id="描述">描述</h3>
<p>n个人在做传递物品的游戏,编号为1-n。游戏规则是这样的：开始时物品可以在任意一人手上，他可把物品传递给<br>
其他人中的任意一位；下一个人可以传递给未接过物品的任意一人。即物品只能经过同一个人一次，而且每次传递<br>
过程都有一个代价；不同的人传给不同的人的代价值之间没有联系；求当物品经过所有n个人后，整个过程的总代<br>
价是多少。<br>
输入</p>
<p>第一行为n,表示共有n个人（16&gt;=n&gt;=2）；<br>
以下为n*n的矩阵，第i+1行、第j列表示物品从编号为i的人传递到编号为j的人所花费的代价，<br>
特别的有第i+1行、第i列为-1（因为物品不能自己传给自己），其他数据均为正整数(&lt;=10000)。<br>
输出</p>
<p>一个数，为最小的代价总和。<br>
样例</p>
<h3 id="输入">输入</h3>
<p>2<br>
-1 9794<br>
2724 –1</p>
<h3 id="输出">输出</h3>
<p>2724</p>
<hr>
<h2 id="题目大意">题目大意</h2>
<p>从任意一个点开始不重复走过n个点，在任意一个点停下求所走过最小代价。</p>
<p>跟售<a href="http://forioi.com/contest/problem?id=23&amp;pid=20">货员的难题</a>有点像似，只是可以从任意一个点出发经过n个点后在任意一个点停下，所以可以省略售货员的难题最后统计答案时加上1到i的1的距离的操作</p>
<h2 id="解题思路">解题思路</h2>
<p>设dp[i][j]表示当状态为i(把i用二进制展开，第k位的0或1就表示第k个人是否传过)时，球正传在第j个人的手上。<br>
设接下来要传的人编号为k。</p>
<ul>
<li>
<p>对于当前状态i，从1一直枚举到(1&lt;&lt;n-1)(即所有人都传过)</p>
</li>
<li>
<p>对于球正在手上的人j，从1枚举到n，但前提是j是在状态i里面的<s>枚举的已经传了的人i状态里面都没有j，而j手上又有球，传个寂寞</s>。所以要进行判断</p>
<ul>
<li>如果i&amp;(1&lt;&lt;j-1)，i的第j位为1，j在i里面表示传过，则再进行下一步操作</li>
</ul>
</li>
<li>
<p>对于接下来要传到的人k，从1枚举到n，但k没在i状态里面，如果k已经传过再传一次就与题意相违背，则要进行判断。</p>
<ul>
<li>如果!(1&amp;(1&lt;&lt;k-1))，i的第k为不为1，k还没传过，则进行下一步操作</li>
</ul>
</li>
<li>
<p>对于传完球的状态，从j已经到k了，原本的状态i得进行改变，将第二进制展开的第k位变为1以表示k已经传过，同样，原本的dp[i][j]中，j要变为k，表示当前已经在第k个人手上。</p>
<ul>
<li>进行i|(1&lt;&lt;k-1)操作，使得i的二进制展开第k位变成1而不改变其他位的值</li>
</ul>
<p>设g[i][j]表示为i传到j的代价<br>
则可得状态转移方程：<br>
<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;&amp;&#039; at position 63: …]+g[j][k]);  (i&amp;̲(1&lt;&lt;j-1) &amp;&amp; !(1…'>dp[i|(1&lt;&lt;k-1)][k]=min(dp[i|(1&lt;&lt;k-1)][k],dp[i][j]+g[j][k]);  (i&amp;(1&lt;&lt;j-1) &amp;&amp; !(1&amp;(1&lt;&lt;k-1))</span></p>
</li>
</ul>
<h2 id="由于最后球可以在任意一个人手上要用for循环遍历一遍dp1n-1j比出最小值">由于最后球可以在任意一个人手上，要用for循环遍历一遍dp[1&lt;&lt;n-1][j]比出最小值</h2>
<p>奉上代码</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int g[20][20],n,dp[1&lt;&lt;16][20];
int main(){
	
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
			scanf(&quot;%d&quot;,&amp;g[i][j]);
			
	memset(dp,63,sizeof(dp));
	for(int i=1;i&lt;=n;i++)
		dp[1&lt;&lt;i-1][i]=0;
	
	for(int i=1;i&lt;=(1&lt;&lt;n)-1;i++)
		for(int j=1;j&lt;=n;j++)
			if(i&amp;(1&lt;&lt;j-1))
				for(int k=1;k&lt;=n;k++)
					if(!(i&amp;(1&lt;&lt;k-1)))
						dp[i|(1&lt;&lt;k-1)][k]=min(dp[i|(1&lt;&lt;k-1)][k],dp[i][j]+g[j][k]);
	
	int ans=1e9;
	for(int i=1;i&lt;=n;i++){
		ans=min(ans,dp[(1&lt;&lt;n)-1][i]);
	}
	printf(&quot;%d&quot;,ans);
	
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[状压dp]售货员的难题]]></title>
        <id>https://yja.hualian.host/post/shou-huo-yuan-de-nan-ti/</id>
        <link href="https://yja.hualian.host/post/shou-huo-yuan-de-nan-ti/">
        </link>
        <updated>2020-07-26T09:20:25.000Z</updated>
        <content type="html"><![CDATA[<p>售货员的难题</p>
<h3 id="描述">描述</h3>
<p>某乡有n个村庄(1&lt;n&lt;15)，有一个售货员，他要到各个村庄去售货，各村庄之间的路程s(0&lt;s&lt;1000)是已知的，且A村到B村与B村到A村的路大多不同。为了提高效率，他从商店出发到每个村庄一次，然后返回商店所在的村，假设商店所在的村庄为1，他不知道选择什么样的路线才能使所走的路程最短。请你帮他选择一条最短的路。<br>
输入<br>
村庄数n和各村之间的路程(均是整数)。<br>
输出<br>
最短的路程<br>
样例</p>
<h3 id="输入">输入</h3>
<p>3        {村庄数}<br>
0 2 1    {村庄1到各村的路程}<br>
1 0 2    {村庄2到各村的路程}<br>
2 1 0    {村庄3到各村的路程}</p>
<h3 id="输出">输出</h3>
<p>3</p>
<hr>
<h3 id="题目大意">题目大意</h3>
<p>n个点，每个点之间都有连边。<br>
求从点1出发不重复经过所有点的路程之和最小。</p>
<h3 id="解题思路">解题思路</h3>
<p>考虑到n范围很小，求经过n个点的最短路径长度，可以使用状压dp来做<br>
设dp[i][j]表示i状态下(把i用二进制展开，如110，第2位为1就表示第2个点已经走过)，j为当前走到的点，dp所存的就是最路程chang长度。<br>
题目所求的就是dp<a href="%E5%A6%82%E5%BD%93n=3%E6%97%B6%EF%BC%8C%E8%BF%90%E7%AE%97%E5%BE%97%E7%9A%84%E7%BB%93%E6%9E%9C%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B1%95%E5%BC%80%E5%B0%B1%E6%98%AF1000-1=111">(1&lt;&lt;n)-1</a>[1]的值<br>
(注意位运算运算级别最低，在同高级运算符合一起时候理清预算顺序打上括号)</p>
<p>而在状态转移时，要考虑已走点的状态，当前所在的点，接下来要去的点。</p>
<ul>
<li>对于已走点的状态i，直接从001枚举到111</li>
<li>对于当前所在的点j，从1开始枚举到n，但不一定j就在已走点的状i态里面，所以要用位运算进行判断。
<ul>
<li>如果1&lt;&lt;(j-1)&amp;i，i状态里面第j位为1，则j在i状态里面，可以进行进一步的讨论</li>
</ul>
</li>
<li>对于接下要求的点k，从1开始枚举到n，但k必须不能走过(走过了再走一遍就会与题意相违背)，所以也要判断。
<ul>
<li>如果!(1&lt;&lt;(k-1)&amp;i)，i状态里面第k位不为1，则k不在i状态里面，可以进行进一步讨论<br>
而还有要考虑的一点：<br>
特殊的点1是起始位置会经过一遍，在走完n-1个点后有回到点1 再经过一次。所以不能直接输出dp[(1&lt;&lt;n)-1][1]。而要再开个for循环遍历一遍dp[(1&lt;&lt;n)-1][i(2~n)]加上i到1的路程，在里面打擂求出最小的路程长度。</li>
</ul>
<hr>
奉上代码</li>
</ul>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,g[20][20],dp[20][1&lt;&lt;16];
int main(){
scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
			scanf(&quot;%d&quot;,&amp;g[i][j]);
			
	memset(dp,63,sizeof(dp));
	dp[1][1]=0;

	for(int i=0;i&lt;=(1&lt;&lt;n)-1;i++)
		for(int j=1;j&lt;=n;j++)
			if(!(i &amp; (1&lt;&lt;(j-1))))
				for(int k=1;k&lt;=n;k++)
					if(i &amp; (1&lt;&lt;(k-1)))
						dp[j][i | (1&lt;&lt;(j-1))]=min(dp[j][i | (1&lt;&lt;(j-1))],dp[k][i]+g[k][j]);
						
	int ans=1e9;
	for(int i=2;i&lt;=n;i++){
		ans=min(ans,dp[i][(1&lt;&lt;n)-1]+g[i][1]);
	}
	
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello jump!]]></title>
        <id>https://yja.hualian.host/post/hello-jump/</id>
        <link href="https://yja.hualian.host/post/hello-jump/">
        </link>
        <updated>2020-07-24T02:25:43.000Z</updated>
        <content type="html"><![CDATA[<p>当你看见这篇文章时你已是一个成熟的jp了。</p>
]]></content>
    </entry>
</feed>