<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yja.hualian.host</id>
    <title>Yja&apos;s blog</title>
    <updated>2020-07-27T11:49:12.874Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yja.hualian.host"/>
    <link rel="self" href="https://yja.hualian.host/atom.xml"/>
    <subtitle>稻花香里说丰年，听取WA声一片</subtitle>
    <logo>https://yja.hualian.host/images/avatar.png</logo>
    <icon>https://yja.hualian.host/favicon.ico</icon>
    <rights>All rights reserved 2020, Yja&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[[动态规划]Cow Pie Treasures]]></title>
        <id>https://yja.hualian.host/post/dong-tai-gui-hua-cow-pie-treasures/</id>
        <link href="https://yja.hualian.host/post/dong-tai-gui-hua-cow-pie-treasures/">
        </link>
        <updated>2020-07-27T10:21:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="description">Description</h3>
<p>最近，奶牛们热衷于把金币包在面粉里，然后把它们烤成馅饼。第i块馅饼中含有Ni(1&lt;=Ni&lt;=25)块金币，并且，这个数字被醒目地标记在馅饼表面。 奶牛们把所有烤好的馅饼在草地上排成了一个R行(1&lt;=R&lt;=100)C列(1&lt;=C&lt;=100)的矩阵。你现在站在坐标为(1,1)的馅饼边上，当然，你可以拿到那块馅饼里的所有金币。你必须从现在的位置，走到草地的另一边，在坐标为(R,C)的馅饼旁边停止走动。每做一次移动，你必须走到下一列的某块馅饼旁边，并且，行数的变动不能超过1（也就是说，如果现在你站在坐标为(r,c)的馅饼边上，下一步你可以走到坐标为(r-1,c+1),(r,c+1),或者(r+1,c+1)的馅饼旁边）。当你从一块馅饼边经过，你就可以拿走馅饼里所有的金币。当然啦，你一定不会愿意因半路离开草地而失去唾手可得的金币，但，最终你一定得停在坐标为(R,C)的馅饼旁边。 现在，你拿到了一张标记着馅饼矩阵中，每一块馅饼含金币数量的表格。那么，按照规则，你最多可以拿到多少金币呢？ 比方说，奶牛们把馅饼排成如下的矩阵，矩阵中的数字表示该位置的馅饼中含金币的数量：<br>
6 5 3 7 9 2 7<br>
2 4 3 5 6 8 6<br>
4 9 9 9 1 5 8<br>
以下是条合法的路线<br>
<img src="https://i.loli.net/2020/07/27/yLuw1Dj6b7Qhnqo.gif" alt="image001.gif" loading="lazy"></p>
<p>按上述的路线进行走动，一共可以获得6+4+9+9+6+5+8=47个金币．按照规则，在这个矩阵中最多可以得到50个金币，路线如下图所示：<br>
<img src="https://i.loli.net/2020/07/27/deXYwVx9OQuyqkI.gif" alt="image002.gif" loading="lazy"></p>
<p>Input<br>
第1行: 两个用空格隔开的整数，R和C<br>
第2..R+1行: 每行包含C个用空格隔开的正整数，依次表示一行中从左往右各个馅饼里金币的数量<br>
Output<br>
输出一个正整数，表示你所能收集到的最大金币数目</p>
<h3 id="sample-input">Sample Input</h3>
<p>3 7<br>
6 5 3 7 9 2 7<br>
2 4 3 5 6 8 6<br>
4 9 9 9 1 5 8</p>
<h3 id="sample-output">Sample Output</h3>
<p>50</p>
<hr>
<h2 id="题目大意">题目大意</h2>
<p>一个n*m的地图从地图左上角走到右下角，每次可以往右，右上，右下走，在每个格子都有一定的金币，每经过一个格子就可以获得格子里面的金币，求从左上角走到左下角可以获得的最大金币的数量。</p>
<hr>
<h2 id="解题思路">解题思路</h2>
<p>根据题目描述可以知道n和m的值比较小，而且牛是不可能往左走的，所以不用考虑重复走的问题，只用一个劲往右莽就行了。<br>
这道题可以采用bfs，但<s>dp不香吗</s>dp求解速度更快代码更短。</p>
<p>设dp[i][j]为从1,1走到i,j所得到的最大金币数，x[i][j]为i,j的格子里面金币的数量。而奶牛只能往右，右上，右下走，对应i行数就不变或，-1，+1，而列数j都要加1向右移动。<br>
易得状态转移方程:<br>
dp[i][j+1]=max(dp[i][j+1],dp[i][j]+x[i][j+1]);<br>
dp[i+1][j+1]=max(dp[i+1][j+1],dp[i][j]+x[i+1][j+1]);<br>
dp[i-1][j+1]=max(dp[i-1][j+1],dp[i][j]+x[i-1][j+1]);</p>
<p>那么直接套个双重for循环i从1到n，j从1到m求出dp[i][j]最终输出dp[n][m]就可以了。<br>
看到这里就恭喜你可以<br>
<strong>WA</strong>掉这道题了。</p>
<p>循环是从左上到右下的，那么以题为例，你的dp[i][j]更新值时的路径就是<img src="https://i.loli.net/2020/07/27/7pqmRjBDCQPVlG9.png" alt="无标题.png" loading="lazy"><br>
那么当你在更新别的dp值时候就会<br>
<img src="https://cdn.jsdelivr.net/gh/pic-cdn/cdn2@latest/2020/07/27/8747665c54e8a9853e17c37711256646.png" alt="" loading="lazy"><br>
对右，右下的更新都没问题，因为还没走到那里。但对右上的更新就不太妙了。右上的元素是已经枚举处理过了，从正在走的点去更新已经走过的点就会出大问题，动态规划其中的要求就是无后效性，即当前的值不会去影响之前已经算好了的值。<br>
当前的值是之前算出来的，而现在又去更新之前的值，所以当前的值也得改变，那所以之前的值又要改变...<s>无限套娃</s></p>
<p>要解决这个问题，改变循环枚举的方式，从原本的i行遍历j列，到j列遍历i行，那么循环遍历的路径就会如下图所示:<br>
<img src="https://cdn.jsdelivr.net/gh/pic-cdn/cdn2@latest/2020/07/27/1fc5e1bd8dcffcda48d6e08ff6e6540c.png" alt="" loading="lazy"><br>
对于任意一个点所更新其他点的情况就会这样<br>
<img src="https://cdn.jsdelivr.net/gh/pic-cdn/cdn2@latest/2020/07/27/e000b6767583c7d8d011cc9708d7c515.png" alt="" loading="lazy"><br>
而那些点都是还没走过的，并且那些点都是不可能走到现在的点（题目说了奶牛只能往右走 ），所以也就不会影响当前的值。<br>
那么只需要把原来的</p>
<pre><code class="language-c">for(int i=1;i&lt;=n;i++){
    for(int j=1;j&lt;=m;j++){
        ...(转移方程)
    }
}
</code></pre>
<p>改成</p>
<pre><code class="language-c">for(int j=1;j&lt;=m;j++){
    for(int i=1;i&lt;=n;i++){
        ...(转移方程)
    }
}
</code></pre>
<p>终于可以AC掉这道题了</p>
<p>提交，评测，刷新<strong>WA</strong>掉了〒▽〒</p>
<hr>
<h2 id="最终解法">最终解法</h2>
<p>题目说了奶牛最多就只能往右下走，所以地图上游戏点是无论如何也走不到的，最多也就能这样<br>
<img src="https://cdn.jsdelivr.net/gh/pic-cdn/cdn2@latest/2020/07/27/32dfef5213fb8a16a656419b08e8df22.png" alt="" loading="lazy"><br>
那些被涂掉的点是无论如何也都走不到的，而在循环时那些点还是会被遍历并更新其他值，根据上图显而易见i要&lt;=j才有可能走到。，所以在循环时候加上一个判断就可以啦</p>
<hr>
<p>奉上代码</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m,x[105][105],dp[105][105];
int main(){
	scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=m;j++){
			scanf(&quot;%d&quot;,&amp;x[i][j]);
		}
	}
	dp[1][1]=x[1][1];
	for(int j=1;j&lt;=m;j++){
		for(int i=1;i&lt;=n &amp;&amp; i&lt;=j;i++){
			dp[i][j+1]=max(dp[i][j+1],dp[i][j]+x[i][j+1]);
			dp[i+1][j+1]=max(dp[i+1][j+1],dp[i][j]+x[i+1][j+1]);
			dp[i-1][j+1]=max(dp[i-1][j+1],dp[i][j]+x[i-1][j+1]);
		}
	}
	printf(&quot;%d&quot;,dp[n][m]);
	return 0;
}
</code></pre>
<p>别往下看了，不会再WA了</p>
<p>真的</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[树形dp]没有上司的舞会]]></title>
        <id>https://yja.hualian.host/post/shu-xing-dpmei-you-shang-si-de-wu-hui/</id>
        <link href="https://yja.hualian.host/post/shu-xing-dpmei-you-shang-si-de-wu-hui/">
        </link>
        <updated>2020-07-26T12:02:09.000Z</updated>
        <content type="html"><![CDATA[<h3 id="描述">描述</h3>
<p>有个公司要举行一场晚会。<br>
为了能玩得开心，公司领导决定：如果邀请了某个人，那么一定不会邀请他的上司<br>
（上司的上司，上司的上司的上司……都可以邀请）。</p>
<h3 id="题目">题目</h3>
<p>每个参加晚会的人都能为晚会增添一些气氛，求一个邀请方案，使气氛值的和最大。<br>
输入</p>
<p>第1行一个整数N（1&lt;=N&lt;=6000）表示公司的人数。<br>
接下来N行每行一个整数。第i行的数表示第i个人的气氛值x(-128&lt;=x&lt;=127)。<br>
接下来每行两个整数L，K。表示第K个人是第L个人的上司。<br>
输入以0 0结束。<br>
输出</p>
<p>一个数，最大的气氛值和。<br>
样例</p>
<h3 id="输入">输入</h3>
<p>7<br>
1<br>
1<br>
1<br>
1<br>
1<br>
1<br>
1<br>
1 3<br>
2 3<br>
6 4<br>
7 4<br>
4 5<br>
3 5<br>
0 0</p>
<h4 id="输出">输出</h4>
<p>5</p>
<hr>
<h2 id="题目大意">题目大意</h2>
<p>n个点，每个点有一个气氛值，当选了第i个点时就不能选它的父亲节点，但是可以选它父亲的父亲，求其能选出气氛值之和最大为多少。</p>
<hr>
<h2 id="解题思路">解题思路</h2>
<p>像这种有主从关系的，不难想到图或树，而根据题意可以判断出这个图是没有环的，上司的上司不可能是上司的下属吧，那就可以直接上树。</p>
<p>注意上司和下属的关系是决定了这棵树是单向边的，题目也没说明那个一定是根节点，所以不能随便从一个点开始搜，先预处理出一个没有入度的点以其为根节点再开始搜<br>
设bool数组vis[i]为i是否有上司，用一个for循环遍历一遍找到一个vis值为零的开始搜即可</p>
<p>设dp[u][j(j只为1或0)]为当第u个人来(j为1)与不来(j为0)时所能产生的最大气氛值。<br>
图的遍历一遍使用dfs,设i的儿子为v，根据题意上司来了其下属就不会来，下属来了其上司就不会来。<br>
但上司不来下属来与不来都可以<br>
可得状态转移方程:<br>
dp[u][0]+=max(dp[v][1],dp[v][0])；<br>
设w[i]为第i个人来能带来的气氛值<br>
dp[u][1]=w[i];<br>
dp[u][1]+=dp[v][0];</p>
<p>设root为树的根节点<br>
最后输出dp[root][0]和dp[root][1]中最大的值即可。</p>
<hr>
<p>奉上代码</p>
<pre><code class="language-c">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,w[6005],tot,head[12005],dp[6005][2];
bool vis[6005];
struct node{
	int nex;
	int to;
}g[12005];
void add(int u,int v){
	g[++tot].nex=head[u];
	g[tot].to=v;
	head[u]=tot;
}
void dfs(int u){
	
	dp[u][0]=0;
	dp[u][1]=w[u];
	int v=0;
	for(int i=head[u];i;i=g[i].nex)
		v=g[i].to,
		dfs(v),
		dp[u][0]+=max(dp[v][1],dp[v][0]),
		dp[u][1]+=dp[v][0];
		
	return ;
}
int main(){
	
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;i++)
		scanf(&quot;%d&quot;,&amp;w[i]);
	
	int u=-1,v=-1;
	while(u!=0 &amp;&amp; v!=0)
		scanf(&quot;%d %d&quot;,&amp;u,&amp;v),
		add(v,u),
		vis[u]=1;
	
	int root=0;
	for(int i=1;i&lt;=n;i++)
		if(!vis[i]){
			root=i;
			break;
		}
	
	dfs(root);
	printf(&quot;%d&quot;,max(dp[root][1],dp[root][0]));
	
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[状压dp]传球游戏之最小总代价]]></title>
        <id>https://yja.hualian.host/post/zhuang-ya-dpchuan-qiu-you-xi-zhi-zui-xiao-zong-dai-jie/</id>
        <link href="https://yja.hualian.host/post/zhuang-ya-dpchuan-qiu-you-xi-zhi-zui-xiao-zong-dai-jie/">
        </link>
        <updated>2020-07-26T11:30:02.000Z</updated>
        <content type="html"><![CDATA[<h3 id="描述">描述</h3>
<p>n个人在做传递物品的游戏,编号为1-n。游戏规则是这样的：开始时物品可以在任意一人手上，他可把物品传递给<br>
其他人中的任意一位；下一个人可以传递给未接过物品的任意一人。即物品只能经过同一个人一次，而且每次传递<br>
过程都有一个代价；不同的人传给不同的人的代价值之间没有联系；求当物品经过所有n个人后，整个过程的总代<br>
价是多少。<br>
输入</p>
<p>第一行为n,表示共有n个人（16&gt;=n&gt;=2）；<br>
以下为n*n的矩阵，第i+1行、第j列表示物品从编号为i的人传递到编号为j的人所花费的代价，<br>
特别的有第i+1行、第i列为-1（因为物品不能自己传给自己），其他数据均为正整数(&lt;=10000)。<br>
输出</p>
<p>一个数，为最小的代价总和。<br>
样例</p>
<h3 id="输入">输入</h3>
<p>2<br>
-1 9794<br>
2724 –1</p>
<h3 id="输出">输出</h3>
<p>2724</p>
<hr>
<h2 id="题目大意">题目大意</h2>
<p>从任意一个点开始不重复走过n个点，在任意一个点停下求所走过最小代价。</p>
<p>跟售<a href="http://forioi.com/contest/problem?id=23&amp;pid=20">货员的难题</a>有点像似，只是可以从任意一个点出发经过n个点后在任意一个点停下，所以可以省略售货员的难题最后统计答案时加上1到i的1的距离的操作</p>
<h2 id="解题思路">解题思路</h2>
<p>设dp[i][j]表示当状态为i(把i用二进制展开，第k位的0或1就表示第k个人是否传过)时，球正传在第j个人的手上。<br>
设接下来要传的人编号为k。</p>
<ul>
<li>
<p>对于当前状态i，从1一直枚举到(1&lt;&lt;n-1)(即所有人都传过)</p>
</li>
<li>
<p>对于球正在手上的人j，从1枚举到n，但前提是j是在状态i里面的<s>枚举的已经传了的人i状态里面都没有j，而j手上又有球，传个寂寞</s>。所以要进行判断</p>
<ul>
<li>如果i&amp;(1&lt;&lt;j-1)，i的第j位为1，j在i里面表示传过，则再进行下一步操作</li>
</ul>
</li>
<li>
<p>对于接下来要传到的人k，从1枚举到n，但k没在i状态里面，如果k已经传过再传一次就与题意相违背，则要进行判断。</p>
<ul>
<li>如果!(1&amp;(1&lt;&lt;k-1))，i的第k为不为1，k还没传过，则进行下一步操作</li>
</ul>
</li>
<li>
<p>对于传完球的状态，从j已经到k了，原本的状态i得进行改变，将第二进制展开的第k位变为1以表示k已经传过，同样，原本的dp[i][j]中，j要变为k，表示当前已经在第k个人手上。</p>
<ul>
<li>进行i|(1&lt;&lt;k-1)操作，使得i的二进制展开第k位变成1而不改变其他位的值</li>
</ul>
<p>设g[i][j]表示为i传到j的代价<br>
则可得状态转移方程：<br>
<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;&amp;&#039; at position 63: …]+g[j][k]);  (i&amp;̲(1&lt;&lt;j-1) &amp;&amp; !(1…'>dp[i|(1&lt;&lt;k-1)][k]=min(dp[i|(1&lt;&lt;k-1)][k],dp[i][j]+g[j][k]);  (i&amp;(1&lt;&lt;j-1) &amp;&amp; !(1&amp;(1&lt;&lt;k-1))</span></p>
</li>
</ul>
<h2 id="由于最后球可以在任意一个人手上要用for循环遍历一遍dp1n-1j比出最小值">由于最后球可以在任意一个人手上，要用for循环遍历一遍dp[1&lt;&lt;n-1][j]比出最小值</h2>
<p>奉上代码</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int g[20][20],n,dp[1&lt;&lt;16][20];
int main(){
	
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
			scanf(&quot;%d&quot;,&amp;g[i][j]);
			
	memset(dp,63,sizeof(dp));
	for(int i=1;i&lt;=n;i++)
		dp[1&lt;&lt;i-1][i]=0;
	
	for(int i=1;i&lt;=(1&lt;&lt;n)-1;i++)
		for(int j=1;j&lt;=n;j++)
			if(i&amp;(1&lt;&lt;j-1))
				for(int k=1;k&lt;=n;k++)
					if(!(i&amp;(1&lt;&lt;k-1)))
						dp[i|(1&lt;&lt;k-1)][k]=min(dp[i|(1&lt;&lt;k-1)][k],dp[i][j]+g[j][k]);
	
	int ans=1e9;
	for(int i=1;i&lt;=n;i++){
		ans=min(ans,dp[(1&lt;&lt;n)-1][i]);
	}
	printf(&quot;%d&quot;,ans);
	
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[状压dp]售货员的难题]]></title>
        <id>https://yja.hualian.host/post/shou-huo-yuan-de-nan-ti/</id>
        <link href="https://yja.hualian.host/post/shou-huo-yuan-de-nan-ti/">
        </link>
        <updated>2020-07-26T09:20:25.000Z</updated>
        <content type="html"><![CDATA[<p>售货员的难题</p>
<h3 id="描述">描述</h3>
<p>某乡有n个村庄(1&lt;n&lt;15)，有一个售货员，他要到各个村庄去售货，各村庄之间的路程s(0&lt;s&lt;1000)是已知的，且A村到B村与B村到A村的路大多不同。为了提高效率，他从商店出发到每个村庄一次，然后返回商店所在的村，假设商店所在的村庄为1，他不知道选择什么样的路线才能使所走的路程最短。请你帮他选择一条最短的路。<br>
输入<br>
村庄数n和各村之间的路程(均是整数)。<br>
输出<br>
最短的路程<br>
样例</p>
<h3 id="输入">输入</h3>
<p>3        {村庄数}<br>
0 2 1    {村庄1到各村的路程}<br>
1 0 2    {村庄2到各村的路程}<br>
2 1 0    {村庄3到各村的路程}</p>
<h3 id="输出">输出</h3>
<p>3</p>
<hr>
<h3 id="题目大意">题目大意</h3>
<p>n个点，每个点之间都有连边。<br>
求从点1出发不重复经过所有点的路程之和最小。</p>
<h3 id="解题思路">解题思路</h3>
<p>考虑到n范围很小，求经过n个点的最短路径长度，可以使用状压dp来做<br>
设dp[i][j]表示i状态下(把i用二进制展开，如110，第2位为1就表示第2个点已经走过)，j为当前走到的点，dp所存的就是最路程chang长度。<br>
题目所求的就是dp<a href="%E5%A6%82%E5%BD%93n=3%E6%97%B6%EF%BC%8C%E8%BF%90%E7%AE%97%E5%BE%97%E7%9A%84%E7%BB%93%E6%9E%9C%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B1%95%E5%BC%80%E5%B0%B1%E6%98%AF1000-1=111">(1&lt;&lt;n)-1</a>[1]的值<br>
(注意位运算运算级别最低，在同高级运算符合一起时候理清预算顺序打上括号)</p>
<p>而在状态转移时，要考虑已走点的状态，当前所在的点，接下来要去的点。</p>
<ul>
<li>对于已走点的状态i，直接从001枚举到111</li>
<li>对于当前所在的点j，从1开始枚举到n，但不一定j就在已走点的状i态里面，所以要用位运算进行判断。
<ul>
<li>如果1&lt;&lt;(j-1)&amp;i，i状态里面第j位为1，则j在i状态里面，可以进行进一步的讨论</li>
</ul>
</li>
<li>对于接下要求的点k，从1开始枚举到n，但k必须不能走过(走过了再走一遍就会与题意相违背)，所以也要判断。
<ul>
<li>如果!(1&lt;&lt;(k-1)&amp;i)，i状态里面第k位不为1，则k不在i状态里面，可以进行进一步讨论<br>
而还有要考虑的一点：<br>
特殊的点1是起始位置会经过一遍，在走完n-1个点后有回到点1 再经过一次。所以不能直接输出dp[(1&lt;&lt;n)-1][1]。而要再开个for循环遍历一遍dp[(1&lt;&lt;n)-1][i(2~n)]加上i到1的路程，在里面打擂求出最小的路程长度。</li>
</ul>
<hr>
奉上代码</li>
</ul>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,g[20][20],dp[20][1&lt;&lt;16];
int main(){
scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
			scanf(&quot;%d&quot;,&amp;g[i][j]);
			
	memset(dp,63,sizeof(dp));
	dp[1][1]=0;

	for(int i=0;i&lt;=(1&lt;&lt;n)-1;i++)
		for(int j=1;j&lt;=n;j++)
			if(!(i &amp; (1&lt;&lt;(j-1))))
				for(int k=1;k&lt;=n;k++)
					if(i &amp; (1&lt;&lt;(k-1)))
						dp[j][i | (1&lt;&lt;(j-1))]=min(dp[j][i | (1&lt;&lt;(j-1))],dp[k][i]+g[k][j]);
						
	int ans=1e9;
	for(int i=2;i&lt;=n;i++){
		ans=min(ans,dp[i][(1&lt;&lt;n)-1]+g[i][1]);
	}
	
	printf(&quot;%d&quot;,ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello jump!]]></title>
        <id>https://yja.hualian.host/post/hello-jump/</id>
        <link href="https://yja.hualian.host/post/hello-jump/">
        </link>
        <updated>2020-07-24T02:25:43.000Z</updated>
        <content type="html"><![CDATA[<p>当你看见这篇文章时你已是一个成熟的jp了。</p>
]]></content>
    </entry>
</feed>